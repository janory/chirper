/**
 * <p>The AkkaServerless module.</p>
 */
declare module "@lightbend/akkaserverless-javascript-sdk" {
    namespace Action {
        /**
         * <p>Context for an action command.</p>
         * @property cancelled - <p>Whether the client is still connected.</p>
         * @property metadata - <p>The metadata associated with the command.</p>
         * @property cloudevent - <p>The CloudEvents metadata associated with the command.</p>
         * @property eventSubject - <p>The origin subject of the CloudEvent. For example, the entity key when the event was emitted from an entity.</p>
         */
        interface ActionCommandContext extends CommandContext {
            /**
             * <p>Write a message.</p>
             * @param message - <p>The protobuf message to write.</p>
             * @param metadata - <p>The metadata associated with the message.</p>
             */
            write(message: any, metadata: Metadata): void;
            /**
             * <p>Register an event handler.</p>
             * @param eventType - <p>The type of the event.</p>
             * @param callback - <p>The callback to handle the event.</p>
             */
            on(eventType: string, callback: (...params: any[]) => any): void;
        }
        /**
         * <p>Context for a unary action command.</p>
         */
        interface UnaryCommandContext extends Action.ActionCommandContext {
        }
        /**
         * <p>Context for a streamed in action command.</p>
         */
        interface StreamedInCommandContext extends Action.StreamedInContext, Action.ActionCommandContext {
        }
        /**
         * <p>Context for a streamed out action command.</p>
         */
        interface StreamedOutCommandContext extends Action.StreamedOutContext {
        }
        /**
         * <p>Context for a streamed action command.</p>
         */
        interface StreamedCommandContext extends Action.StreamedInContext, Action.StreamedOutContext {
        }
        /**
         * <p>Context for an action command that returns a streamed message out.</p>
         */
        interface StreamedOutContext extends Action.ActionCommandContext {
            /**
             * <p>Send a reply</p>
             * @param reply - <p>The reply to send</p>
             */
            reply(reply: replies.Reply): void;
            /**
             * <p>Terminate the outgoing stream of messages.</p>
             */
            end(): void;
        }
        /**
         * <p>Context for an action command that handles streamed messages in.</p>
         */
        interface StreamedInContext extends Action.ActionCommandContext {
            /**
             * <p>Cancel the incoming stream of messages.</p>
             */
            cancel(): void;
        }
        /**
         * <p>Options for a action.</p>
         */
        type options = {
            /**
             * <p>The directories to include when looking up imported protobuf files.</p>
             * @defaultValue ["."]
             */
            includeDirs?: string[];
        };
        /**
         * <p>A unary action command handler.</p>
         * @param command - <p>The command message, this will be of the type of the gRPC service call input type.</p>
         * @param context - <p>The command context.</p>
         */
        type unaryCommandHandler = (command: any, context: Action.UnaryCommandContext) => undefined | any | Promise<any> | replies.Reply;
        /**
         * <p>A streamed in action command handler.</p>
         * @param context - <p>The command context.</p>
         */
        type streamedInCommandHandler = (context: Action.StreamedInCommandContext) => undefined | any | Promise<any>;
        /**
         * <p>A streamed out command handler.</p>
         * @param command - <p>The command message, this will be of the type of the gRPC service call input type.</p>
         * @param context - <p>The command context.</p>
         */
        type streamedOutCommandHandler = (command: any, context: Action.StreamedOutCommandContext) => void;
        /**
         * <p>A streamed command handler.</p>
         * @param context - <p>The command context.</p>
         */
        type streamedCommandHandler = (context: Action.StreamedCommandContext) => void;
        /**
         * <p>An action command handler.</p>
         */
        type ActionCommandHandler = Action.unaryCommandHandler | Action.streamedInCommandHandler | Action.streamedOutCommandHandler | Action.streamedCommandHandler;
    }
    interface Action extends Entity {
    }
    /**
     * <p>Create a new action.</p>
     * @param desc - <p>A descriptor or list of descriptors to parse, containing the service to serve.</p>
     * @param serviceName - <p>The fully qualified name of the service that provides this interface.</p>
     * @param [options] - <p>The options for this action</p>
     */
    class Action implements Entity {
        constructor(desc: string | string[], serviceName: string, options?: Action.options);
        /**
         * <p>The command handlers.</p>
         * <p>The names of the properties must match the names of the service calls specified in the gRPC descriptor</p>
         */
        commandHandlers: {
            [key: string]: Action.ActionCommandHandler;
        };
        /**
         * <p>Lookup a protobuf message type.</p>
         * <p>This is provided as a convenience to lookup protobuf message types for use with events and snapshots.</p>
         * @param messageType - <p>The fully qualified name of the type to lookup.</p>
         */
        lookupType(messageType: string): void;
    }
    /**
     * <p>An Akka Serverless server.</p>
     */
    interface Server {
        /**
         * <p>Start the server.</p>
         * @param [options] - <p>The options for starting the server.</p>
         * @returns <p>The port number that the server bound to.</p>
         */
        start(options?: Server.startOptions): number;
        /**
         * <p>Shutdown the server</p>
         */
        shutdown(): void;
    }
    namespace Server {
        /**
         * <p>Options for starting a server.</p>
         */
        type startOptions = {
            /**
             * <p>The address to bind to.</p>
             * @defaultValue "0.0.0.0"
             */
            bindAddress?: string;
            /**
             * <p>The port to bind to, specify zero for a random ephemeral port.</p>
             * @defaultValue 8080
             */
            bindPort?: number;
        };
    }
    /**
     * <p>An Akka Serverless entity.</p>
     */
    interface Entity extends Server {
    }
    interface AkkaServerless extends Server {
    }
    /**
     * <p>Create a new akkaserverless server.</p>
     * @param [options] - <p>The options for this server.</p>
     */
    class AkkaServerless implements Server {
        constructor(options?: AkkaServerless.options);
        /**
         * <p>Add an component to this server.</p>
         * @param components - <p>The components to add.</p>
         * @returns <p>This server.</p>
         */
        addComponent(...components:import("../proto/protobuf-bundle").akkaserverless.protocol.Component[]): AkkaServerless;
        /**
         * <p>Start this server.</p>
         * @param [options] - <p>The options for starting.</p>
         * @returns <p>The port that was bound to, useful for when a random ephemeral port was requested.</p>
         */
        start(options?: Server.startOptions): number;
        /**
         * <p>Shutdown the server</p>
         */
        shutdown(): void;
    }
    namespace AkkaServerless {
        /**
         */
        type options = {
            /**
             * <p>The name of this service.</p>
             * @defaultValue <name from package.json>
             */
            serviceName?: string;
            /**
             * <p>The version of this service.</p>
             * @defaultValue <version from package.json>
             */
            serviceVersion?: string;
            /**
             * <p>A path to a compiled Protobuf FileDescriptor set,
             as output by protoc --descriptor_set_out=somefile.desc. This file must contain all of the component services that
             this user function serves.</p>
             * @defaultValue "user-function.desc"
             */
            descriptorSetPath?: string;
        };
    }
    /**
     * <p>CloudEvent data.</p>
     * @property specversion - <p>The CloudEvent spec version</p>
     */
    interface CloudEvent {
    }
    /**
     * <p>Context for an entity.</p>
     * @property entityId - <p>The id of the entity that the command is for.</p>
     * @property commandId - <p>The id of the command.</p>
     * @property replyMetadata - <p>The metadata to send with a reply.</p>
     */
    interface EntityContext {
    }
    /**
     * <p>Effect context.</p>
     * @property metadata - <p>The metadata associated with the command.</p>
     * @property cloudevent - <p>The CloudEvents metadata associated with the command.</p>
     */
    interface EffectContext {
        /**
         * <p>DEPRECATED. Emit an effect after processing this command.</p>
         * @param method - <p>The entity service method to invoke.</p>
         * @param message - <p>The message to send to that service.</p>
         * @param synchronous - <p>Whether the effect should be execute synchronously or not.</p>
         * @param metadata - <p>Metadata to send with the effect.</p>
         */
        effect(method: any, message: any, synchronous: boolean, metadata: Metadata): void;
        /**
         * <p>Fail handling this command.</p>
         * <p>An alternative to using this is to return a failed Reply created with 'ReplyFactory.failed'.</p>
         * @param msg - <p>The failure message.</p>
         */
        fail(msg: any): void;
    }
    /**
     * <p>Context for a command.</p>
     */
    interface CommandContext extends EffectContext {
        /**
         * <p>DEPRECATED. Forward this command to another service component call.</p>
         * @param method - <p>The service component method to invoke.</p>
         * @param message - <p>The message to send to that service component.</p>
         * @param metadata - <p>Metadata to send with the forward.</p>
         */
        thenForward(method: any, message: any, metadata: Metadata): void;
        /**
         * <p>DEPRECATED. Forward this command to another service component call, use 'ReplyFactory.forward' instead.</p>
         * @param method - <p>The service component method to invoke.</p>
         * @param message - <p>The message to send to that service component.</p>
         * @param metadata - <p>Metadata to send with the forward.</p>
         */
        forward(method: any, message: any, metadata: Metadata): void;
    }
    namespace EventSourcedEntity {
        /**
         * <p>Context for an event sourced command.</p>
         */
        interface EventSourcedEntityCommandContext extends CommandContext, EntityContext {
            /**
             * <p>Persist an event.</p>
             * <p>The event won't be persisted until the reply is sent to the proxy. Then, the event will be persisted
             * before the reply is sent back to the client.</p>
             * @param event - <p>The event to emit.</p>
             */
            emit(event: Serializable): void;
        }
        /**
         * <p>An event sourced entity command handler.</p>
         * @param command - <p>The command message, this will be of the type of the gRPC service call input type.</p>
         * @param state - <p>The entity state.</p>
         * @param context - <p>The command context.</p>
         */
        type commandHandler = (command: any, state: Serializable, context: EventSourcedEntity.EventSourcedEntityCommandContext) => undefined | any | replies.Reply;
        /**
         * <p>An event sourced entity event handler.</p>
         * @param event - <p>The event.</p>
         * @param state - <p>The entity state.</p>
         */
        type eventHandler = (event: Serializable, state: Serializable) => Serializable;
        /**
         * <p>An event sourced entity behavior.</p>
         */
        type behavior = {
            /**
             * <p>The command handlers.</p>
             <p>The names of the properties must match the names of the service calls specified in the gRPC descriptor for this
             event sourced entities service.</p>
             */
            commandHandlers: {
                [key: string]: EventSourcedEntity.commandHandler;
            };
            /**
             * <p>The event handlers.</p>
             <p>The names of the properties must match the short names of the events.</p>
             */
            eventHandlers: {
                [key: string]: EventSourcedEntity.eventHandler;
            };
        };
        /**
         * <p>An event sourced entity behavior callback.</p>
         * <p>This callback takes the current entity state, and returns a set of handlers to handle commands and events for it.</p>
         * @param state - <p>The entity state.</p>
         */
        type behaviorCallback = (state: Serializable) => EventSourcedEntity.behavior;
        /**
         * <p>Initial state callback.</p>
         * <p>This is invoked if the entity is started with no snapshot.</p>
         * @param entityId - <p>The entity id.</p>
         */
        type initialCallback = (entityId: string) => Serializable;
        /**
         * <p>Options for an event sourced entity.</p>
         */
        type options = {
            /**
             * <p>A snapshot will be persisted every time this many events are emitted.
             It is strongly recommended to not disable snapshotting unless it is known that
             event sourced entities will never have more than 100 events (in which case
             the default will anyway not trigger any snapshots)</p>
             * @defaultValue 100
             */
            snapshotEvery?: number;
            /**
             * <p>The directories to include when looking up imported protobuf files.</p>
             * @defaultValue ["."]
             */
            includeDirs?: string[];
            /**
             * <p>Whether serialization of primitives should be supported when
             serializing events and snapshots.</p>
             */
            serializeAllowPrimitives?: boolean;
            /**
             * <p>Whether serialization should fallback to using JSON if an event
             or snapshot can't be serialized as a protobuf.</p>
             */
            serializeFallbackToJson?: boolean;
        };
    }
    interface EventSourcedEntity extends Entity {
    }
    /**
     * <p>Create a new event sourced entity.</p>
     * @param desc - <p>A descriptor or list of descriptors to parse, containing the service to serve.</p>
     * @param serviceName - <p>The fully qualified name of the service that provides this entities interface.</p>
     * @param entityType - <p>The entity type name for all event source entities of this type. This will be prefixed
     * onto the entityId when storing the events for this entity. Be aware that the
     * chosen name must be stable through the entity lifecycle.  Never change it after deploying
     * a service that stored data of this type</p>
     * @param [options] - <p>The options for this event sourced entity</p>
     */
    class EventSourcedEntity implements Entity {
        constructor(desc: string | string[], serviceName: string, entityType: string, options?: EventSourcedEntity.options);
        /**
         * <p>Lookup a protobuf message type.</p>
         * <p>This is provided as a convenience to lookup protobuf message types for use with events and snapshots.</p>
         * @param messageType - <p>The fully qualified name of the type to lookup.</p>
         */
        lookupType(messageType: string): void;
        /**
         * <p>The initial state callback.</p>
         */
        initial: EventSourcedEntity.initialCallback;
        /**
         * <p>Set the initial state callback.</p>
         * @param callback - <p>The initial state callback.</p>
         * @returns <p>This entity.</p>
         */
        setInitial(callback: EventSourcedEntity.initialCallback): EventSourcedEntity;
        /**
         * <p>The behavior callback.</p>
         */
        behavior: EventSourcedEntity.behaviorCallback;
        /**
         * <p>Set the behavior callback.</p>
         * @param callback - <p>The behavior callback.</p>
         * @returns <p>This entity.</p>
         */
        setBehavior(callback: EventSourcedEntity.behaviorCallback): EventSourcedEntity;
    }
    /**
     * <p>A metadata value. Can either be a string or a buffer.</p>
     */
    type MetadataValue = string | Buffer;
    /**
     * <p>Akka Serverless metadata.</p>
     * <p>Metadata is treated as case insensitive on lookup, and case sensitive on set. Multiple values per key are supported,
     * setting a value will add it to the current values for that key. You should delete first if you wish to replace a
     * value.</p>
     * <p>Values can either be strings or byte buffers. If a non string or byte buffer value is set, it will be converted to
     * a string using toString.</p>
     * @param entries - <p>The list of entries</p>
     */
    interface Metadata {
        /**
         * <p>The metadata expressed as an object.</p>
         * <p>The object keys are case insensitive, ie, <code>metadata.foo</code> and <code>metadata.Foo</code> both return the same value. If there
         * are multiple values for a given key, the first one set for that key will be returned. Setting a value will add it
         * to the list of existing values for that key.</p>
         */
        getMap: {
            [key: string]: MetadataValue;
        };
        /**
         * <p>Get all the values for the given key.</p>
         * <p>The key is case insensitive.</p>
         * @param key - <p>The key to get.</p>
         * @returns <p>All the values, or an empty array if no values exist for the key.</p>
         */
        get(key: string): MetadataValue[];
        /**
         * <p>Set a given key value.</p>
         * <p>This will append the key value to the metadata, it won't replace any existing values for existing keys.</p>
         * @param key - <p>The key to set.</p>
         * @param value - <p>The value to set.</p>
         */
        set(key: string, value: MetadataValue): void;
        /**
         * <p>Delete all values with the given key.</p>
         * <p>The key is case insensitive.</p>
         * @param key - <p>The key to delete.</p>
         */
        delete(key: string): void;
        /**
         * <p>Whether there exists a metadata value for the given key.</p>
         * <p>The key is case insensitive.</p>
         * @param key - <p>The key to check.</p>
         */
        has(key: string): void;
        /**
         * <p>Clear the metadata.</p>
         */
        clear(): void;
        /**
         * <p>The metadata, expressed as a CloudEvent.</p>
         */
        cloudevent: CloudEvent;
    }
    /**
     * <p>This is any type that has been returned by the protobufjs Message.create method.</p>
     * <p>It should have a encode() method on it.</p>
     */
    type SerializableProtobufMessage = any;
    /**
     * <p>Any type that has a type property on it can be serialized as JSON, with the value of the type property describing
     * the type of the value.</p>
     */
    type TypedJson = {
        /**
         * <p>The type of the object.</p>
         */
        type: string;
    };
    /**
     * <p>A type that is serializable.</p>
     */
    type Serializable = SerializableProtobufMessage | TypedJson | any | string | number | boolean | Long | Buffer;
    /**
     * <p>All Replicated Data types and Replicated Data type support classes.</p>
     */
    namespace replicatedentity {
        interface Flag extends replicatedentity.ReplicatedData {
        }
        /**
         * <p>A flag Replicated Data type.</p>
         * <p>A flag starts out as being false (disabled), and then can be set to true (enabled). Once set to true, it stays true.</p>
         */
        class Flag implements replicatedentity.ReplicatedData {
            /**
             * <p>Whether this flag is enabled or not.</p>
             */
            readonly value: boolean;
            /**
             * <p>Enable this flag.</p>
             * @returns <p>This flag.</p>
             */
            enable(): replicatedentity.Flag;
        }
        interface GCounter extends replicatedentity.ReplicatedData {
        }
        /**
         * <p>A Grow-only counter Replicated Data type.</p>
         * <p>As the name suggests, a grow only counter can be incremented, but not decremented.</p>
         * <p>The value is stored as a 64-bit unsigned long, hence values over <code>2^64</code> can't be represented.</p>
         */
        class GCounter implements replicatedentity.ReplicatedData {
            /**
             * <p>The value as a long.</p>
             */
            readonly longValue: Long;
            /**
             * <p>The value as a number. Note that once the value exceeds <code>2^53</code>, this will not be an accurate
             * representation of the value. If you expect it to exceed <code>2^53</code>, {@link replicatedentity.GCounter#longValue} should be
             * used instead.</p>
             */
            readonly value: number;
            /**
             * <p>Increment the counter by the given number.</p>
             * @param increment - <p>The amount to increment the counter by.</p>
             * @returns <p>This counter.</p>
             */
            increment(increment: Long | number): replicatedentity.GCounter;
        }
        interface GSet extends replicatedentity.ReplicatedData {
        }
        /**
         * <p>A Grow-only Set Replicated Data type.</p>
         * <p>A grow only set can have elements added to it, but not removed.</p>
         */
        class GSet implements replicatedentity.ReplicatedData {
            /**
             * <p>Does this set contain the given element?</p>
             * @param element - <p>The element to check.</p>
             * @returns <p>True if the set contains the element.</p>
             */
            has(element: Serializable): boolean;
            /**
             * <p>The size of this set.</p>
             */
            readonly size: number;
            /**
             * <p>Execute the given callback for each element.</p>
             * @param callback - <p>The callback to handle each element.</p>
             */
            forEach(callback: replicatedentity.GSet.forEachCallback): void;
            /**
             * <p>Create an iterator for this set.</p>
             */
            iterator(): Iterator<Serializable>;
            /**
             * <p>Add an element to this set.</p>
             * @param element - <p>The element to add.</p>
             * @returns <p>This set.</p>
             */
            add(element: Serializable): replicatedentity.GSet;
        }
        namespace GSet {
            /**
             * <p>Callback for handling elements iterated through by {@link replicatedentity.GSet#forEach}.</p>
             * @param element - <p>The element.</p>
             */
            type forEachCallback = (element: Serializable) => void;
        }
        /**
         * <p>A Replicated Data type.</p>
         */
        interface ReplicatedData {
        }
        /**
         * <p>A clock that may be used by {@link replicatedentity.LWWRegister}.</p>
         */
        type Clock = any;
        /**
         * <p>An enum of all clocks that can be used by {@link replicatedentity.LWWRegister}.</p>
         */
        enum Clocks {
            DEFAULT,
            REVERSE,
            CUSTOM,
            CUSTOM_AUTO_INCREMENT
        }
        /**
         * <p>A write consistency setting for replication of state updates.</p>
         */
        type WriteConsistency = any;
        /**
         * <p>An enum of write consistency settings, for replication of state updates.</p>
         */
        enum WriteConsistencies {
            LOCAL,
            MAJORITY,
            ALL
        }
        interface LWWRegister extends replicatedentity.ReplicatedData {
        }
        /**
         * <p>A Last-Write-Wins Register Replicated Data type.</p>
         * <p>A last write wins register uses a clock to determine which of two concurrent updates should win. The clock is
         * represented as a number. The default clock uses the proxies system time, custom clocks can supply a custom number
         * to be used. If two clock values are equal, the write from the node with the lowest address wins.</p>
         * @param value - <p>A value to hold in the register.</p>
         * @param [clock = Clocks.DEFAULT] - <p>The clock to use.</p>
         * @param [customClockValue = 0] - <p>The custom clock value, if using a custom clock.</p>
         */
        class LWWRegister implements replicatedentity.ReplicatedData {
            constructor(value: Serializable, clock?: replicatedentity.Clock, customClockValue?: number);
            /**
             * <p>The value of this register.</p>
             * <p>Setting it will cause it to be set with the default clock.</p>
             */
            value: Serializable;
            /**
             * <p>Set the the value using a custom clock.</p>
             * @param value - <p>The value to set.</p>
             * @param [clock = Clocks.DEFAULT] - <p>The clock.</p>
             * @param [customClockValue = 0] - <p>Ignored if a custom clock isn't specified.</p>
             */
            setWithClock(value: Serializable, clock?: replicatedentity.Clock, customClockValue?: number): void;
        }
        interface ORMap extends replicatedentity.ReplicatedData {
        }
        /**
         * <p>An Observed-Removed Map Replicated Data type.</p>
         * <p>Observed-Removed-Map's are a mapping of keys (which can be any {@link Serializable}) to
         * Replicated Data types. Values of the map are merged together. Elements can be added and removed, however, when an
         * element is removed and then added again, it's possible that the old value will be merged with the new, depending on
         * whether the remove was replicated to all nodes before the add was.</p>
         * <p>Note that while the map may contain different types of Replicated Data for different keys, a given key may not change
         * its type, and doing so will likely result in the Replicated Data entering a non mergable state, from which it can't
         * recover.</p>
         */
        class ORMap implements replicatedentity.ReplicatedData {
            /**
             * <p>Generator for default values.</p>
             * <p>This is invoked by get when the current map has no Replicated Data defined for the key.</p>
             * <p>If this returns a Replicated Data object, it will be added to the map.</p>
             * <p>Care should be taken when using this, since it means that the get method can trigger elements to be created. If
             * using default values, the get method should not be used in queries where an empty value for the Replicated Data
             * means the value is not present.</p>
             */
            defaultValue: replicatedentity.ORMap.defaultValueCallback;
            /**
             * <p>Check whether this map contains a value of the given key.</p>
             * @param key - <p>The key to check.</p>
             * @returns <p>True if this map contains a value of the given key.</p>
             */
            has(key: Serializable): boolean;
            /**
             * <p>The number of elements in this map.</p>
             */
            readonly size: number;
            /**
             * <p>Execute the given callback for each element.</p>
             * @param callback - <p>The callback to handle each element.</p>
             */
            forEach(callback: replicatedentity.ORMap.forEachCallback): void;
            /**
             * <p>Return an iterator of the entries of this map.</p>
             */
            entries(): Iterator<any[]>;
            /**
             * <p>Return an iterator of the entries of this map.</p>
             */
            iterator(): Iterator<any[]>;
            /**
             * <p>Return an iterator of the values of this map.</p>
             */
            values(): Iterator<replicatedentity.ReplicatedData>;
            /**
             * <p>Return an iterator of the keys of this map.</p>
             */
            keys(): Iterator<Serializable>;
            /**
             * <p>Get the value at the given key.</p>
             * @param key - <p>The key to get.</p>
             * @returns <p>The Replicated Data value, or undefined if no value is defined at that key.</p>
             */
            get(key: Serializable): undefined | replicatedentity.ReplicatedData;
            /**
             * <p>A representation of this map as an object.</p>
             * <p>All entries whose keys are strings will be properties of this object, and setting any property of the object will
             * insert that property as a key into the map.</p>
             */
            asObject: {
                [key: string]: replicatedentity.ReplicatedData;
            };
            /**
             * <p>Set the given value for the given key.</p>
             * @param key - <p>The key to set.</p>
             * @param value - <p>The value to set.</p>
             * @returns <p>This map.</p>
             */
            set(key: Serializable, value: replicatedentity.ReplicatedData): replicatedentity.ORMap;
            /**
             * <p>Delete the value at the given key.</p>
             * @param key - <p>The key to delete.</p>
             * @returns <p>This map.</p>
             */
            delete(key: Serializable): replicatedentity.ORMap;
            /**
             * <p>Clear all entries from this map.</p>
             * @returns <p>This map.</p>
             */
            clear(): replicatedentity.ORMap;
        }
        namespace ORMap {
            /**
             * <p>Generator for default values.</p>
             * <p>This is invoked by get when the current map has no Replicated Data defined for the key.</p>
             * <p>If this returns a Replicated Data object, it will be added to the map.</p>
             * <p>Care should be taken when using this, since it means that the get method can trigger elements to be created. If
             * using default values, the get method should not be used in queries where an empty value for the Replicated Data
             * means the value is not present.</p>
             * @param key - <p>The key the default value is being generated for.</p>
             */
            type defaultValueCallback = (key: Serializable) => undefined | replicatedentity.ReplicatedData;
            /**
             * <p>Callback for handling elements iterated through by {@link replicatedentity.ORMap#forEach}.</p>
             * @param value - <p>The Replicated Data value.</p>
             * @param key - <p>The key.</p>
             * @param This - <p>map.</p>
             */
            type forEachCallback = (value: replicatedentity.ReplicatedData, key: Serializable, This: ORMap) => void;
        }
        interface ORSet extends replicatedentity.ReplicatedData {
        }
        /**
         * <p>An Observed-Removed Set Replicated Data type.</p>
         * <p>Observed-Removed-Set's are a set of {@link Serializable} values. Elements can be added and removed.</p>
         */
        class ORSet implements replicatedentity.ReplicatedData {
            /**
             * <p>Does this set contain the given element?</p>
             * @param element - <p>The element to check.</p>
             * @returns <p>True if the set contains the element.</p>
             */
            has(element: Serializable): boolean;
            /**
             * <p>The number of elements in this set.</p>
             */
            readonly size: number;
            /**
             * <p>Execute the given callback for each element.</p>
             * @param callback - <p>The callback to handle each element.</p>
             */
            forEach(callback: replicatedentity.ORSet.forEachCallback): void;
            /**
             * <p>Create an iterator for this set.</p>
             */
            iterator(): Iterator<Serializable>;
            /**
             * <p>Add an element to this set.</p>
             * @param element - <p>The element to add.</p>
             * @returns <p>This set.</p>
             */
            add(element: Serializable): replicatedentity.ORSet;
            /**
             * <p>Remove an element from this set.</p>
             * @param element - <p>The element to delete.</p>
             * @returns <p>This set.</p>
             */
            delete(element: Serializable): replicatedentity.ORSet;
            /**
             * <p>Remove all elements from this set.</p>
             * @returns <p>This set.</p>
             */
            clear(): replicatedentity.ORSet;
        }
        namespace ORSet {
            /**
             * <p>Callback for handling elements iterated through by {@link replicatedentity.ORSet#forEach}.</p>
             * @param element - <p>The element.</p>
             */
            type forEachCallback = (element: Serializable) => void;
        }
        interface PNCounter extends replicatedentity.ReplicatedData {
        }
        /**
         * <p>A Positive-Negative Counter Replicated Data type.</p>
         * <p>A counter that can be incremented and decremented.</p>
         * <p>The value is stored as a 64-bit signed long, hence values over <code>2^63 - 1</code> and less than <code>2^63</code> can't be represented.</p>
         */
        class PNCounter implements replicatedentity.ReplicatedData {
            /**
             * <p>The value as a long.</p>
             */
            readonly longValue: Long;
            /**
             * <p>The value as a number. Note that once the value exceeds <code>2^53</code>, this will not be an accurate
             * representation of the value. If you expect it to exceed <code>2^53</code>, {@link replicatedentity.PNCounter#longValue}
             * should be used instead.</p>
             */
            readonly value: number;
            /**
             * <p>Increment the counter by the given number.</p>
             * @param increment - <p>The amount to increment the counter by. If negative, it will be decremented instead.</p>
             * @returns <p>This counter.</p>
             */
            increment(increment: Long | number): replicatedentity.PNCounter;
            /**
             * <p>Decrement the counter by the given number.</p>
             * @param decrement - <p>The amount to decrement the counter by. If negative, it will be incremented instead.</p>
             * @returns <p>This counter.</p>
             */
            decrement(decrement: Long | number): replicatedentity.PNCounter;
        }
        interface Vote extends replicatedentity.ReplicatedData {
        }
        /**
         * <p>A Vote Replicated Data type.</p>
         * <p>A Vote Replicated Data type allows all nodes an a cluster to vote on a condition, such as whether a user is online.</p>
         */
        class Vote implements replicatedentity.ReplicatedData {
            /**
             * <p>The number of nodes that have voted for this condition.</p>
             */
            readonly votesFor: number;
            /**
             * <p>The total number of nodes that have voted.</p>
             */
            readonly totalVoters: number;
            /**
             * <p>Whether at least one node has voted for this condition.</p>
             */
            readonly atLeastOne: boolean;
            /**
             * <p>Whether a majority of nodes have voted for this condition.</p>
             */
            readonly majority: boolean;
            /**
             * <p>Whether all of nodes have voted for this condition.</p>
             */
            readonly all: boolean;
            /**
             * <p>The current nodes vote.</p>
             * <p>Setting this will update the current nodes vote accordingly.</p>
             */
            vote: boolean;
        }
        namespace ReplicatedEntityCommandContext {
            /**
             * <p>Callback for handling {@link replicatedentity.ReplicatedEntityCommandContext#onStateChange}
             * events for a Replicated Entity, specific to a given streamed connection.</p>
             * <p>The callback may not modify the Replicated Entity state, doing so will cause an error.</p>
             * @param state - <p>The current Replicated Data state that has changed</p>
             * @param context - <p>The context for the state change.</p>
             */
            type onStateChangeCallback = (state: replicatedentity.ReplicatedData, context: replicatedentity.StateChangedContext) => undefined | any;
            /**
             * <p>Callback for handling {@link replicatedentity.ReplicatedEntityCommandContext#onStreamCancel}
             * events for a Replicated Entity, specific to a given streamed connection.</p>
             * <p>The callback may modify the Replicated Entity state if it pleases.</p>
             * @param state - <p>The current Replicated Data state that has changed</p>
             * @param context - <p>The context for the stream cancellation.</p>
             */
            type onStreamCancelCallback = (state: replicatedentity.ReplicatedData, context: replicatedentity.StreamCancelledContext) => void;
        }
        /**
         * <p>Context for a Replicated Entity command handler.</p>
         */
        interface ReplicatedEntityCommandContext extends replicatedentity.StateManagementContext, CommandContext, EntityContext {
            /**
             * <p>Set a callback for handling state change events.</p>
             * <p>This may only be invoked on streamed commands. If invoked on a non streamed command, it will throw an error.</p>
             * <p>This will be invoked every time the state of this Replicated Entity changes, allowing the callback to send
             * messages to the stream.</p>
             */
            onStateChange: replicatedentity.ReplicatedEntityCommandContext.onStateChangeCallback;
            /**
             * <p>Set a callback for handling the stream cancelled event.</p>
             * <p>This may only be invoked on streamed commands. If invoked on a non streamed command, it will throw an error.</p>
             * <p>This will be invoked if the client initiated a cancel, it will not be invoked if the stream was ended by
             * invoking {@link replicatedentity.StateChangedContext#end}.</p>
             */
            onStreamCancel: replicatedentity.ReplicatedEntityCommandContext.onStreamCancelCallback;
            /**
             * <p>Whether this command is streamed or not.</p>
             */
            streamed: boolean;
            /**
             * <p>Set the write consistency for replication of Replicated Entity state.</p>
             */
            writeConsistency: replicatedentity.WriteConsistency;
        }
        /**
         * <p>Context that allows managing a Replicated Entity's state.</p>
         */
        interface StateManagementContext {
            /**
             * <p>Delete this Replicated Entity.</p>
             */
            delete(): void;
            /**
             * <p>The Replicated Data state for a Replicated Entity.
             * It may only be set once, if it's already set, an error will be thrown.</p>
             */
            state: replicatedentity.ReplicatedData;
        }
        /**
         * <p>Context passed to {@link replicatedentity.ReplicatedEntityCommandContext#onStateChange} handlers.</p>
         */
        interface StateChangedContext extends CommandContext, EntityContext {
            /**
             * <p>The Replicated Data state for a Replicated Entity.</p>
             */
            state: replicatedentity.ReplicatedData;
            /**
             * <p>End this stream.</p>
             */
            end(): void;
        }
        /**
         * <p>Context passed to {@link replicatedentity.ReplicatedEntityCommandContext#onStreamCancel} handlers.</p>
         */
        interface StreamCancelledContext extends EffectContext, EntityContext, replicatedentity.StateManagementContext {
        }
        namespace ReplicatedEntity {
            /**
             * <p>Options for creating a Replicated Entity.</p>
             */
            type options = {
                /**
                 * <p>The directories to include when looking up imported protobuf files.</p>
                 */
                includeDirs: string[];
            };
            /**
             * <p>A command handler callback.</p>
             * @param command - <p>The command message, this will be of the type of the gRPC service call input type.</p>
             * @param context - <p>The command context.</p>
             */
            type commandHandler = (command: any, context: replicatedentity.ReplicatedEntityCommandContext) => undefined | any;
            /**
             * <p>A state set handler callback.</p>
             * <p>This is invoked whenever a new state is set on the Replicated Entity, to allow the state to be enriched with domain
             * specific properties and methods. This may be due to the state being set explicitly from a command handler on the
             * command context, or implicitly as the default value, or implicitly when a new state is received from the proxy.</p>
             * @param state - <p>The Replicated Data state that was set.</p>
             * @param entityId - <p>The id of the entity.</p>
             */
            type onStateSetCallback = (state: replicatedentity.ReplicatedData, entityId: string) => void;
            /**
             * <p>A callback that is invoked to create a default value if the Akka Serverless proxy doesn't send an existing one.</p>
             * @param entityId - <p>The id of the entity.</p>
             */
            type defaultValueCallback = (entityId: string) => any;
        }
        interface ReplicatedEntity extends Entity {
        }
        /**
         * <p>Create a Replicated Entity.</p>
         * @param desc - <p>The file name of a protobuf descriptor or set of descriptors containing the
         * Replicated Entity service.</p>
         * @param serviceName - <p>The fully qualified name of the gRPC service that this Replicated Entity implements.</p>
         * @param entityType - <p>The entity type name, used to namespace entities of different Replicated Data
         * types in the same service.</p>
         * @param [options] - <p>The options.</p>
         */
        class ReplicatedEntity implements Entity {
            constructor(desc: string | string[], serviceName: string, entityType: string, options?: replicatedentity.ReplicatedEntity.options);
            /**
             * <p>The command handlers.</p>
             * <p>The names of the properties must match the names of the service calls specified in the gRPC descriptor for this
             * Replicated Entity service.</p>
             */
            commandHandlers: {
                [key: string]: replicatedentity.ReplicatedEntity.commandHandler;
            };
            /**
             * <p>A callback that is invoked whenever the Replicated Data state is set for this Replicated Entity.</p>
             * <p>This is invoked whenever a new Replicated Data state is set on the Replicated Entity, to allow the state to be
             * enriched with domain specific properties and methods. This may be due to the state being set explicitly from a
             * command handler on the command context, or implicitly as the default value, or implicitly when a new state is
             * received from the proxy.</p>
             */
            onStateSet: replicatedentity.ReplicatedEntity.onStateSetCallback;
            /**
             * <p>A callback that is invoked to create a default value if the Akka Serverless proxy doesn't send an existing one.</p>
             */
            defaultValue: replicatedentity.ReplicatedEntity.defaultValueCallback;
            /**
             * <p>Lookup a Protobuf message type.</p>
             * <p>This is provided as a convenience to lookup protobuf message types for use, for example, as values in sets and
             * maps.</p>
             * @param messageType - <p>The fully qualified name of the type to lookup.</p>
             */
            lookupType(messageType: string): void;
        }
    }
    namespace replies {
        /**
         * <p>A return type to allow returning forwards or failures, and attaching effects to messages.</p>
         */
        class Reply {
            /**
             * <p>Attach the given effect(s) to this reply</p>
             * @param method - <p>The entity service method to invoke.</p>
             * @param message - <p>The message to send to that service.</p>
             * @param [synchronous] - <p>Whether the effect should be execute synchronously or not, default is false.</p>
             * @param [metadata] - <p>Metadata to send with the effect.</p>
             * @returns <p>This reply after adding the effect.</p>
             */
            addEffect(method: protobuf.Method, message: any, synchronous?: boolean, metadata?: Metadata): replies.Reply;
            /**
             * <p>Attach the given effect(s) to this reply</p>
             * @param effects - <p>One or more service calls to execute as side effects</p>
             * @returns <p>This reply after adding the effects.</p>
             */
            addEffects(effects: Effect[]): replies.Reply;
            /**
             * <p>Whether this reply is empty: does not have a message, forward, or failure.</p>
             * @returns <p>Whether the reply is empty.</p>
             */
            isEmpty(): boolean;
        }
        /**
         * @param method - <p>The entity service method to invoke.</p>
         * @param message - <p>The message to send to that service.</p>
         * @param [synchronous] - <p>Whether the effect should be execute synchronously or not, default is false</p>
         * @param [metadata] - <p>Metadata to send with the effect.</p>
         */
        class Effect {
            constructor(method: protobuf.Method, message: any, synchronous?: boolean, metadata?: Metadata);
        }
        /**
         * <p>Factory for creating various types of replies from a component</p>
         */
        class ReplyFactory {
            /**
             * <p>Create a message reply.</p>
             * @param message - <p>the message to reply with</p>
             * @param [metadata] - <p>Optional metadata to pass with the reply</p>
             * @returns <p>A message reply</p>
             */
            message(message: any, metadata?: Metadata): replies.Reply;
            /**
             * @param method - <p>The service call representing the forward.</p>
             * @param message - <p>The message to forward</p>
             * @param [metadata] - <p>Optional metadata to pass with the forwarded message</p>
             * @returns <p>A forward reply.</p>
             */
            forward(method: protobuf.Method, message: any, metadata?: Metadata): replies.Reply;
            /**
             * @param description - <p>A description of the failure</p>
             * @returns <p>A failure reply.</p>
             */
            failure(description: string): replies.Reply;
            /**
             * <p>Create a reply that contains neither a message nor a forward nor a failure.</p>
             * <p>This may be useful for emitting effects without sending a message.</p>
             * @returns <p>An empty reply</p>
             */
            noReply(): replies.Reply;
        }
    }
    namespace ValueEntity {
        /**
         * <p>Context for an value entity command.</p>
         */
        interface ValueEntityCommandContext extends CommandContext, EntityContext {
            /**
             * <p>Persist the updated state.</p>
             * <p>The state won't be persisted until the reply is sent to the proxy. Then, the state will be persisted
             * before the reply is sent back to the client.</p>
             * @param newState - <p>The state to store.</p>
             */
            updateState(newState: Serializable): void;
            /**
             * <p>Delete this entity.</p>
             */
            deleteState(): void;
        }
        /**
         * <p>Value entity command handlers
         * The names of the properties must match the names of the service calls specified in the gRPC descriptor for this value entities service.</p>
         */
        type commandHandlers = {
            [key: string]: ValueEntity.commandHandler;
        };
        /**
         * <p>A command handler for one service call to the value entity</p>
         * @param command - <p>The command message, this will be of the type of the gRPC service call input type.</p>
         * @param state - <p>The entity state.</p>
         * @param context - <p>The command context.</p>
         */
        type commandHandler = (command: any, state: Serializable, context: ValueEntity.ValueEntityCommandContext) => undefined | any | replies.Reply;
        /**
         * <p>Initial state callback.</p>
         * <p>This is invoked if the entity is started with no snapshot.</p>
         * @param entityId - <p>The entity id.</p>
         */
        type initialCallback = (entityId: string) => Serializable;
        /**
         * <p>Options for a value entity.</p>
         */
        type options = {
            /**
             * <p>The directories to include when looking up imported protobuf files.</p>
             * @defaultValue ["."]
             */
            includeDirs?: string[];
            /**
             * <p>Whether serialization of primitives should be supported when
             serializing the state.</p>
             */
            serializeAllowPrimitives?: boolean;
            /**
             * <p>Whether serialization should fallback to using JSON if the state
             can't be serialized as a protobuf.</p>
             */
            serializeFallbackToJson?: boolean;
        };
    }
    interface ValueEntity extends Entity {
    }
    /**
     * <p>Create a new value entity.</p>
     * @param desc - <p>A descriptor or list of descriptors to parse, containing the service to serve.</p>
     * @param serviceName - <p>The fully qualified name of the service that provides this entities interface.</p>
     * @param entityType - <p>The entity type name for all value entities of this type. Never change it after deploying
     * a service that stored data of this type</p>
     * @param [options] - <p>The options for this entity</p>
     */
    class ValueEntity implements Entity {
        constructor(desc: string | string[], serviceName: string, entityType: string, options?: ValueEntity.options);
        /**
         * <p>Lookup a protobuf message type.</p>
         * <p>This is provided as a convenience to lookup protobuf message types for use with state.</p>
         * @param messageType - <p>The fully qualified name of the type to lookup.</p>
         */
        lookupType(messageType: string): void;
        /**
         * <p>The initial state callback.</p>
         */
        initial: ValueEntity.initialCallback;
        /**
         * <p>Set the initial state callback.</p>
         * @param callback - <p>The initial state callback.</p>
         * @returns <p>This entity.</p>
         */
        setInitial(callback: ValueEntity.initialCallback): ValueEntity;
        /**
         * <p>Set the command handlers of the entity.</p>
         * @param handlers - <p>The command handler callbacks.</p>
         * @returns <p>This entity.</p>
         */
        setCommandHandlers(handlers: ValueEntity.commandHandlers): ValueEntity;
    }
    namespace View {
        /**
         * <p>Context for a view update event.</p>
         * @property eventSubject - <p>The origin subject of the CloudEvent. For example, the entity key when the event was emitted from an entity.</p>
         * @property metadata - <p>for the event</p>
         */
        interface UpdateHandlerContext {
        }
        /**
         * <p>Options for a view.</p>
         */
        type options = {
            /**
             * <p>The id for the view, used for persisting the view.</p>
             * @defaultValue serviceName
             */
            viewId?: string;
            /**
             * <p>The directories to include when looking up imported protobuf files.</p>
             * @defaultValue ["."]
             */
            includeDirs?: string[];
        };
        /**
         * <p>View handlers
         * The names of the properties must match the names of all the view methods specified in the gRPC
         * descriptor.</p>
         */
        type handlers = {
            [key: string]: View.handler;
        };
        /**
         * <p>A handler for transforming an incoming event and the previous view state into a new state</p>
         * @param event - <p>The event, this will be of the type of the gRPC event handler input type.</p>
         * @param state - <p>The previous view state or 'undefined' if no previous state was stored.</p>
         * @param context - <p>The view handler context.</p>
         */
        type handler = (event: any, state: undefined | Serializable, context: View.UpdateHandlerContext) => undefined | Serializable;
    }
    interface View extends Entity {
    }
    /**
     * <p>Create a new view.</p>
     * @param desc - <p>A descriptor or list of descriptors to parse, containing the service to serve.</p>
     * @param serviceName - <p>The fully qualified name of the service that provides this interface.</p>
     * @param [options] - <p>The options for this view</p>
     */
    class View implements Entity {
        constructor(desc: string | string[], serviceName: string, options?: View.options);
        /**
         * <p>Lookup a protobuf message type.</p>
         * <p>This is provided as a convenience to lookup protobuf message types.</p>
         * @param messageType - <p>The fully qualified name of the type to lookup.</p>
         */
        lookupType(messageType: string): void;
        /**
         * <p>Set the update handlers of the view. Only used for updates where event transformation is enabled through
         * &quot;transform_updates: true&quot; in the grpc descriptor.</p>
         * @param handlers - <p>The handler callbacks.</p>
         * @returns <p>This view.</p>
         */
        setUpdateHandlers(handlers: View.handlers): View;
    }
}

